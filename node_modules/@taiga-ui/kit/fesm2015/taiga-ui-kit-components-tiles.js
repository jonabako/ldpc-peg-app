import * as i0 from '@angular/core';
import { ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Inject, Input, Output, HostBinding, HostListener, Injectable, ViewChild, Directive, NgModule } from '@angular/core';
import { MutationObserverService, MUTATION_OBSERVER_INIT } from '@ng-web-apis/mutation-observer';
import { TuiDestroyService, TuiResizeService, tuiArrayShallowEquals, tuiPx, tuiGetActualTarget, tuiIsElement } from '@taiga-ui/cdk';
import * as i2 from 'rxjs';
import { Subject, timer, BehaviorSubject, Subscription, combineLatest } from 'rxjs';
import { debounce, filter, map, distinctUntilChanged, startWith, debounceTime } from 'rxjs/operators';
import { __decorate } from 'tslib';
import { shouldCall } from '@tinkoff/ng-event-plugins';

class TuiTilesComponent {
    constructor(el) {
        this.el = el;
        this.el$ = new Subject();
        this.debounce = 0;
        this.orderChange = this.el$.pipe(debounce(() => timer(this.debounce)), filter(this.filter.bind(this)), map(element => this.reorder(element)));
        this.element = null;
        this.order$ = new BehaviorSubject(new Map());
    }
    set order(map) {
        this.order$.next(map);
    }
    get order() {
        return this.order$.value;
    }
    rearrange(element) {
        this.el$.next(element);
    }
    filter(element) {
        return !!this.element && !!element && this.element !== element;
    }
    reorder(element) {
        var _a, _b;
        const elements = Array.from(this.el.nativeElement.children);
        const currentIndex = elements.indexOf(this.element || element);
        const newIndex = elements.indexOf(element);
        const order = this.order.size
            ? new Map(this.order)
            : new Map(elements.map((_, index) => [index, index]));
        const dragged = (_a = order.get(currentIndex)) !== null && _a !== void 0 ? _a : currentIndex;
        const placement = (_b = order.get(newIndex)) !== null && _b !== void 0 ? _b : newIndex;
        order.set(currentIndex, placement);
        order.set(newIndex, dragged);
        this.order$.next(order);
        return order;
    }
}
TuiTilesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTilesComponent, deps: [{ token: ElementRef }], target: i0.ɵɵFactoryTarget.Component });
TuiTilesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiTilesComponent, selector: "tui-tiles", inputs: { debounce: "debounce", order: "order" }, outputs: { orderChange: "orderChange" }, host: { listeners: { "pointerleave.silent": "rearrange()" }, properties: { "class._dragged": "this.element" } }, providers: [
        TuiDestroyService,
        TuiResizeService,
        MutationObserverService,
        {
            provide: MUTATION_OBSERVER_INIT,
            useValue: { childList: true },
        },
    ], ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: ["tui-tiles{position:relative;z-index:0;display:grid;grid-auto-flow:dense;justify-items:stretch}tui-tiles._dragged tui-tile>.t-wrapper{pointer-events:none}tui-tiles._dragged tui-tile:not(._dragged)>.t-wrapper{transition-property:all;transition-duration:var(--tui-duration, .3s);transition-timing-function:ease-in-out;transition-delay:1ms}tui-tiles:not(._dragged) tui-tile._dragged>.t-wrapper{transition-property:all;transition-duration:var(--tui-duration, .3s);transition-timing-function:ease-in-out;transition-delay:1ms}tui-tile>.t-wrapper{position:absolute;z-index:0;border-radius:inherit}tui-tile._dragged>.t-wrapper{z-index:1;transition:none}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTilesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-tiles',
                    template: '<ng-content></ng-content>',
                    styleUrls: ['./tiles.style.less'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        TuiDestroyService,
                        TuiResizeService,
                        MutationObserverService,
                        {
                            provide: MUTATION_OBSERVER_INIT,
                            useValue: { childList: true },
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }]; }, propDecorators: { debounce: [{
                type: Input
            }], order: [{
                type: Input
            }], orderChange: [{
                type: Output
            }], element: [{
                type: HostBinding,
                args: ['class._dragged']
            }], rearrange: [{
                type: HostListener,
                args: ['pointerleave.silent']
            }] } });

class TuiTileService {
    constructor(el, tiles, resize$, mutation$) {
        this.el = el;
        this.tiles = tiles;
        this.resize$ = resize$;
        this.mutation$ = mutation$;
        this.sub = new Subscription();
        this.offset$ = new BehaviorSubject([NaN, NaN]);
        this.position$ = combineLatest([
            this.offset$.pipe(distinctUntilChanged(tuiArrayShallowEquals)),
            this.resize$.pipe(startWith(null)),
            this.mutation$.pipe(startWith(null)),
            this.tiles.order$.pipe(debounceTime(0)),
        ]).pipe(map(([offset]) => offset));
    }
    init(element) {
        this.sub.add(this.position$.subscribe(offset => {
            this.setPosition(element, offset);
            this.setRect(element, offset);
        }));
    }
    setOffset(offset) {
        this.offset$.next(offset);
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    getRect([left, top]) {
        return {
            top: Number.isNaN(top) ? this.el.nativeElement.offsetTop : top,
            left: Number.isNaN(left) ? this.el.nativeElement.offsetLeft : left,
            width: this.el.nativeElement.clientWidth,
            height: this.el.nativeElement.clientHeight,
            right: NaN,
            bottom: NaN,
        };
    }
    setRect({ style }, offset) {
        const { top, left, width, height } = this.getRect(offset);
        style.top = tuiPx(top);
        style.left = tuiPx(left);
        style.width = tuiPx(width);
        style.height = tuiPx(height);
    }
    setPosition(element, [left]) {
        if (!Number.isNaN(left)) {
            element.style.setProperty('position', 'fixed');
            return;
        }
        const { style } = element;
        const rect = element.getBoundingClientRect();
        const host = this.el.nativeElement.getBoundingClientRect();
        style.removeProperty('position');
        style.top = tuiPx(rect.top - host.top + this.el.nativeElement.offsetTop);
        style.left = tuiPx(rect.left - host.left + this.el.nativeElement.offsetLeft);
    }
}
TuiTileService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTileService, deps: [{ token: ElementRef }, { token: TuiTilesComponent }, { token: TuiResizeService }, { token: MutationObserverService }], target: i0.ɵɵFactoryTarget.Injectable });
TuiTileService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTileService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTileService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: TuiTilesComponent, decorators: [{
                    type: Inject,
                    args: [TuiTilesComponent]
                }] }, { type: i2.Observable, decorators: [{
                    type: Inject,
                    args: [TuiResizeService]
                }] }, { type: i2.Observable, decorators: [{
                    type: Inject,
                    args: [MutationObserverService]
                }] }]; } });

class TuiTileComponent {
    constructor(service, el, tiles) {
        this.service = service;
        this.el = el;
        this.tiles = tiles;
        this.width = 1;
        this.height = 1;
        this.dragged = false;
    }
    get column() {
        return `span var(--tui-width, ${this.width})`;
    }
    get row() {
        return `span var(--tui-height, ${this.height})`;
    }
    get element() {
        return this.el.nativeElement;
    }
    onEnter() {
        this.tiles.rearrange(this.element);
    }
    onDrag(offset) {
        const dragged = !Number.isNaN(offset[0]);
        this.dragged = this.dragged || dragged;
        this.tiles.element = dragged ? this.element : null;
        this.service.setOffset(offset);
    }
    onTransitionEnd() {
        this.dragged = false;
    }
    ngAfterViewInit() {
        if (this.wrapper) {
            this.service.init(this.wrapper.nativeElement);
        }
    }
    ngOnDestroy() {
        if (this.tiles.element === this.element) {
            this.tiles.element = null;
        }
    }
}
TuiTileComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTileComponent, deps: [{ token: TuiTileService }, { token: ElementRef }, { token: TuiTilesComponent }], target: i0.ɵɵFactoryTarget.Component });
TuiTileComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TuiTileComponent, selector: "tui-tile", inputs: { width: "width", height: "height" }, host: { listeners: { "pointerenter": "onEnter()" }, properties: { "class._dragged": "this.dragged", "style.gridColumn": "this.column", "style.gridRow": "this.row" } }, providers: [TuiTileService], viewQueries: [{ propertyName: "wrapper", first: true, predicate: ["wrapper"], descendants: true }], ngImport: i0, template: "<div\n    #wrapper\n    class=\"t-wrapper\"\n    (transitionend.self)=\"onTransitionEnd()\"\n>\n    <ng-content></ng-content>\n</div>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTileComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tui-tile',
                    templateUrl: './tile.template.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [TuiTileService],
                }]
        }], ctorParameters: function () { return [{ type: TuiTileService, decorators: [{
                    type: Inject,
                    args: [TuiTileService]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: TuiTilesComponent, decorators: [{
                    type: Inject,
                    args: [TuiTilesComponent]
                }] }]; }, propDecorators: { wrapper: [{
                type: ViewChild,
                args: ['wrapper']
            }], width: [{
                type: Input
            }], height: [{
                type: Input
            }], dragged: [{
                type: HostBinding,
                args: ['class._dragged']
            }], column: [{
                type: HostBinding,
                args: ['style.gridColumn']
            }], row: [{
                type: HostBinding,
                args: ['style.gridRow']
            }], onEnter: [{
                type: HostListener,
                args: ['pointerenter']
            }] } });

function isInteracting(x = NaN) {
    return !Number.isNaN(x) || !Number.isNaN(this['x']);
}
function isDragging() {
    return !Number.isNaN(this['x']);
}
class TuiTileHandleDirective {
    constructor(tile) {
        this.tile = tile;
        this.x = NaN;
        this.y = NaN;
    }
    onStart(event) {
        const target = tuiGetActualTarget(event);
        const { x, y, pointerId } = event;
        if (tuiIsElement(target)) {
            target.releasePointerCapture(pointerId);
        }
        this.onPointer(x, y);
    }
    onPointer(x = NaN, y = NaN) {
        const { left, top } = this.tile.element.getBoundingClientRect();
        this.x = x - left;
        this.y = y - top;
        this.tile.onDrag([NaN, NaN]);
    }
    onMove(x, y) {
        this.tile.onDrag([x - this.x, y - this.y]);
    }
}
TuiTileHandleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTileHandleDirective, deps: [{ token: TuiTileComponent }], target: i0.ɵɵFactoryTarget.Directive });
TuiTileHandleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiTileHandleDirective, selector: "[tuiTileHandle]", host: { listeners: { "pointerdown.silent": "onStart($event)", "document:pointerup.silent": "onPointer()", "document:pointermove.silent": "onMove($event.x,$event.y)" }, properties: { "style.touchAction": "\"none\"", "style.userSelect": "\"none\"" } }, ngImport: i0 });
__decorate([
    shouldCall(isInteracting)
], TuiTileHandleDirective.prototype, "onPointer", null);
__decorate([
    shouldCall(isDragging)
], TuiTileHandleDirective.prototype, "onMove", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTileHandleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiTileHandle]',
                    host: {
                        '[style.touchAction]': '"none"',
                        '[style.userSelect]': '"none"',
                    },
                }]
        }], ctorParameters: function () { return [{ type: TuiTileComponent, decorators: [{
                    type: Inject,
                    args: [TuiTileComponent]
                }] }]; }, propDecorators: { onStart: [{
                type: HostListener,
                args: ['pointerdown.silent', ['$event']]
            }], onPointer: [{
                type: HostListener,
                args: ['document:pointerup.silent']
            }], onMove: [{
                type: HostListener,
                args: ['document:pointermove.silent', ['$event.x', '$event.y']]
            }] } });

class TuiTilesModule {
}
TuiTilesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTilesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TuiTilesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTilesModule, declarations: [TuiTilesComponent, TuiTileComponent, TuiTileHandleDirective], exports: [TuiTilesComponent, TuiTileComponent, TuiTileHandleDirective] });
TuiTilesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTilesModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiTilesModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TuiTilesComponent, TuiTileComponent, TuiTileHandleDirective],
                    exports: [TuiTilesComponent, TuiTileComponent, TuiTileHandleDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { TuiTileComponent, TuiTileHandleDirective, TuiTileService, TuiTilesComponent, TuiTilesModule };
//# sourceMappingURL=taiga-ui-kit-components-tiles.js.map
