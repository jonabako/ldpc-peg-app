import { DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH, RANGE_SEPARATOR_CHAR, TuiDay, TuiDayRange, } from '@taiga-ui/cdk';
function parseWithLimit(value, config) {
    return TuiDay.normalizeParse(value.slice(0, DATE_FILLER_LENGTH), config.dateFormat).dayLimit(config.min, config.max);
}
function processRawValue(value, config) {
    const { dateFormat, dateSeparator } = config;
    switch (value.length) {
        case DATE_FILLER_LENGTH:
            return parseWithLimit(value, config).toString(dateFormat, dateSeparator);
        case DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length:
            return (parseWithLimit(value, config).toString(dateFormat, dateSeparator) +
                RANGE_SEPARATOR_CHAR);
        case DATE_RANGE_FILLER_LENGTH:
            return config.value &&
                config.value.toString(dateFormat, dateSeparator) === value
                ? value
                : TuiDayRange.sort(parseWithLimit(value.slice(0, DATE_FILLER_LENGTH), config), parseWithLimit(value.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), config)).toString(dateFormat, dateSeparator);
        default:
            return value;
    }
}
/**
 * @deprecated Use {@link https://maskito.dev/kit/date-range DateRange} from {@link https://github.com/taiga-family/maskito Maskito} instead
 * TODO: delete in v4.0
 * Normalizes date in formatted string
 *
 * Normalizes when:
 *
 * 1. It is a single date
 * 2. It is a single date and a separator
 * 3. It is two dates and a separator between them
 *
 * In **other** cases, the value does not change.
 *
 * @param config with min and max date
 * @return mask pipe handler that handles `min` and `max`
 */
export function tuiCreateAutoCorrectedDateRangePipe(config) {
    return value => ({ value: processRawValue(value, config) });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLWF1dG8tY29ycmVjdGVkLWRhdGUtcmFuZ2UtcGlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2tpdC91dGlscy9tYXNrL2NyZWF0ZS1hdXRvLWNvcnJlY3RlZC1kYXRlLXJhbmdlLXBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILGtCQUFrQixFQUNsQix3QkFBd0IsRUFDeEIsb0JBQW9CLEVBRXBCLE1BQU0sRUFDTixXQUFXLEdBQ2QsTUFBTSxlQUFlLENBQUM7QUFTdkIsU0FBUyxjQUFjLENBQUMsS0FBYSxFQUFFLE1BQXVDO0lBQzFFLE9BQU8sTUFBTSxDQUFDLGNBQWMsQ0FDeEIsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsa0JBQWtCLENBQUMsRUFDbEMsTUFBTSxDQUFDLFVBQVUsQ0FDcEIsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdkMsQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLEtBQWEsRUFBRSxNQUF1QztJQUMzRSxNQUFNLEVBQUMsVUFBVSxFQUFFLGFBQWEsRUFBQyxHQUFHLE1BQU0sQ0FBQztJQUUzQyxRQUFRLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDbEIsS0FBSyxrQkFBa0I7WUFDbkIsT0FBTyxjQUFjLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDN0UsS0FBSyxrQkFBa0IsR0FBRyxvQkFBb0IsQ0FBQyxNQUFNO1lBQ2pELE9BQU8sQ0FDSCxjQUFjLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsYUFBYSxDQUFDO2dCQUNqRSxvQkFBb0IsQ0FDdkIsQ0FBQztRQUNOLEtBQUssd0JBQXdCO1lBQ3pCLE9BQU8sTUFBTSxDQUFDLEtBQUs7Z0JBQ2YsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxLQUFLLEtBQUs7Z0JBQzFELENBQUMsQ0FBQyxLQUFLO2dCQUNQLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUNaLGNBQWMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUMxRCxjQUFjLENBQ1YsS0FBSyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsRUFDN0QsTUFBTSxDQUNULENBQ0osQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2hEO1lBQ0ksT0FBTyxLQUFLLENBQUM7S0FDcEI7QUFDTCxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsTUFBTSxVQUFVLG1DQUFtQyxDQUMvQyxNQUF1QztJQUV2QyxPQUFPLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDLEtBQUssRUFBRSxlQUFlLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUFDLENBQUMsQ0FBQztBQUM5RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBEQVRFX0ZJTExFUl9MRU5HVEgsXG4gICAgREFURV9SQU5HRV9GSUxMRVJfTEVOR1RILFxuICAgIFJBTkdFX1NFUEFSQVRPUl9DSEFSLFxuICAgIFR1aURhdGVNb2RlLFxuICAgIFR1aURheSxcbiAgICBUdWlEYXlSYW5nZSxcbn0gZnJvbSAnQHRhaWdhLXVpL2Nkayc7XG5pbXBvcnQge1R1aVRleHRNYXNrUGlwZUhhbmRsZXIsIFR1aVdpdGhPcHRpb25hbE1pbk1heFdpdGhWYWx1ZX0gZnJvbSAnQHRhaWdhLXVpL2NvcmUnO1xuXG5pbnRlcmZhY2UgVHVpQXV0b0NvcnJlY3RlZERhdGVQaXBlQ29uZmlnc1xuICAgIGV4dGVuZHMgVHVpV2l0aE9wdGlvbmFsTWluTWF4V2l0aFZhbHVlPFR1aURheVJhbmdlIHwgbnVsbCwgVHVpRGF5PiB7XG4gICAgZGF0ZUZvcm1hdDogVHVpRGF0ZU1vZGU7XG4gICAgZGF0ZVNlcGFyYXRvcjogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpdGhMaW1pdCh2YWx1ZTogc3RyaW5nLCBjb25maWc6IFR1aUF1dG9Db3JyZWN0ZWREYXRlUGlwZUNvbmZpZ3MpOiBUdWlEYXkge1xuICAgIHJldHVybiBUdWlEYXkubm9ybWFsaXplUGFyc2UoXG4gICAgICAgIHZhbHVlLnNsaWNlKDAsIERBVEVfRklMTEVSX0xFTkdUSCksXG4gICAgICAgIGNvbmZpZy5kYXRlRm9ybWF0LFxuICAgICkuZGF5TGltaXQoY29uZmlnLm1pbiwgY29uZmlnLm1heCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdWYWx1ZSh2YWx1ZTogc3RyaW5nLCBjb25maWc6IFR1aUF1dG9Db3JyZWN0ZWREYXRlUGlwZUNvbmZpZ3MpOiBzdHJpbmcge1xuICAgIGNvbnN0IHtkYXRlRm9ybWF0LCBkYXRlU2VwYXJhdG9yfSA9IGNvbmZpZztcblxuICAgIHN3aXRjaCAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgREFURV9GSUxMRVJfTEVOR1RIOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aExpbWl0KHZhbHVlLCBjb25maWcpLnRvU3RyaW5nKGRhdGVGb3JtYXQsIGRhdGVTZXBhcmF0b3IpO1xuICAgICAgICBjYXNlIERBVEVfRklMTEVSX0xFTkdUSCArIFJBTkdFX1NFUEFSQVRPUl9DSEFSLmxlbmd0aDpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgcGFyc2VXaXRoTGltaXQodmFsdWUsIGNvbmZpZykudG9TdHJpbmcoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcikgK1xuICAgICAgICAgICAgICAgIFJBTkdFX1NFUEFSQVRPUl9DSEFSXG4gICAgICAgICAgICApO1xuICAgICAgICBjYXNlIERBVEVfUkFOR0VfRklMTEVSX0xFTkdUSDpcbiAgICAgICAgICAgIHJldHVybiBjb25maWcudmFsdWUgJiZcbiAgICAgICAgICAgICAgICBjb25maWcudmFsdWUudG9TdHJpbmcoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcikgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgIDogVHVpRGF5UmFuZ2Uuc29ydChcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVdpdGhMaW1pdCh2YWx1ZS5zbGljZSgwLCBEQVRFX0ZJTExFUl9MRU5HVEgpLCBjb25maWcpLFxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlV2l0aExpbWl0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZShEQVRFX0ZJTExFUl9MRU5HVEggKyBSQU5HRV9TRVBBUkFUT1JfQ0hBUi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICkudG9TdHJpbmcoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgaHR0cHM6Ly9tYXNraXRvLmRldi9raXQvZGF0ZS1yYW5nZSBEYXRlUmFuZ2V9IGZyb20ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlnYS1mYW1pbHkvbWFza2l0byBNYXNraXRvfSBpbnN0ZWFkXG4gKiBUT0RPOiBkZWxldGUgaW4gdjQuMFxuICogTm9ybWFsaXplcyBkYXRlIGluIGZvcm1hdHRlZCBzdHJpbmdcbiAqXG4gKiBOb3JtYWxpemVzIHdoZW46XG4gKlxuICogMS4gSXQgaXMgYSBzaW5nbGUgZGF0ZVxuICogMi4gSXQgaXMgYSBzaW5nbGUgZGF0ZSBhbmQgYSBzZXBhcmF0b3JcbiAqIDMuIEl0IGlzIHR3byBkYXRlcyBhbmQgYSBzZXBhcmF0b3IgYmV0d2VlbiB0aGVtXG4gKlxuICogSW4gKipvdGhlcioqIGNhc2VzLCB0aGUgdmFsdWUgZG9lcyBub3QgY2hhbmdlLlxuICpcbiAqIEBwYXJhbSBjb25maWcgd2l0aCBtaW4gYW5kIG1heCBkYXRlXG4gKiBAcmV0dXJuIG1hc2sgcGlwZSBoYW5kbGVyIHRoYXQgaGFuZGxlcyBgbWluYCBhbmQgYG1heGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1aUNyZWF0ZUF1dG9Db3JyZWN0ZWREYXRlUmFuZ2VQaXBlKFxuICAgIGNvbmZpZzogVHVpQXV0b0NvcnJlY3RlZERhdGVQaXBlQ29uZmlncyxcbik6IFR1aVRleHRNYXNrUGlwZUhhbmRsZXIge1xuICAgIHJldHVybiB2YWx1ZSA9PiAoe3ZhbHVlOiBwcm9jZXNzUmF3VmFsdWUodmFsdWUsIGNvbmZpZyl9KTtcbn1cbiJdfQ==