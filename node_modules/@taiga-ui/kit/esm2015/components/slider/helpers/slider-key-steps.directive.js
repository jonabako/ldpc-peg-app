import { ChangeDetectorRef, Directive, ElementRef, forwardRef, HostListener, Inject, Input, Optional, Self, } from '@angular/core';
import { NgControl } from '@angular/forms';
import { AbstractTuiControl, tuiAssert, tuiClamp, tuiIsNativeFocused, } from '@taiga-ui/cdk';
import { tuiKeyStepValueToPercentage, tuiPercentageToKeyStepValue, } from '@taiga-ui/kit/utils';
import { TuiSliderComponent } from '../slider.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "../slider.component";
export class TuiSliderKeyStepsDirective extends AbstractTuiControl {
    constructor(control, cdr, el, slider) {
        super(control, cdr);
        this.el = el;
        this.slider = slider;
    }
    get nativeFocusableElement() {
        return this.computedDisabled ? null : this.el.nativeElement;
    }
    get focused() {
        return tuiIsNativeFocused(this.nativeFocusableElement);
    }
    get min() {
        return this.keySteps[0][1];
    }
    get max() {
        return this.keySteps[this.keySteps.length - 1][1];
    }
    updateControlValue() {
        this.value = tuiPercentageToKeyStepValue(this.slider.valuePercentage, this.keySteps);
    }
    writeValue(controlValue) {
        if (controlValue === null) {
            return;
        }
        const clampedControlValue = tuiClamp(controlValue, this.min, this.max);
        ngDevMode &&
            tuiAssert.assert(controlValue === clampedControlValue, '\n[SliderKeySteps]: You cannot programmatically set value which is less/more than min/max');
        this.slider.value = this.transformToNativeValue(clampedControlValue);
    }
    getFallbackValue() {
        return 0;
    }
    transformToNativeValue(controlValue) {
        const { min, max } = this.slider;
        const newValuePercentage = tuiKeyStepValueToPercentage(controlValue, this.keySteps);
        return (newValuePercentage * (max - min)) / 100 + min;
    }
}
TuiSliderKeyStepsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderKeyStepsDirective, deps: [{ token: NgControl, optional: true, self: true }, { token: ChangeDetectorRef }, { token: ElementRef }, { token: forwardRef(() => TuiSliderComponent) }], target: i0.ɵɵFactoryTarget.Directive });
TuiSliderKeyStepsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiSliderKeyStepsDirective, selector: "input[tuiSlider][keySteps]", inputs: { keySteps: "keySteps" }, host: { listeners: { "input": "updateControlValue()", "change": "updateControlValue()" }, properties: { "attr.aria-valuenow": "safeCurrentValue", "attr.aria-valuemin": "min", "attr.aria-valuemax": "max", "disabled": "computedDisabled" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiSliderKeyStepsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[tuiSlider][keySteps]',
                    host: {
                        '[attr.aria-valuenow]': 'safeCurrentValue',
                        '[attr.aria-valuemin]': 'min',
                        '[attr.aria-valuemax]': 'max',
                        '[disabled]': 'computedDisabled',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }, {
                    type: Inject,
                    args: [NgControl]
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Inject,
                    args: [ChangeDetectorRef]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i2.TuiSliderComponent, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => TuiSliderComponent)]
                }] }]; }, propDecorators: { keySteps: [{
                type: Input
            }], updateControlValue: [{
                type: HostListener,
                args: ['input']
            }, {
                type: HostListener,
                args: ['change']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLWtleS1zdGVwcy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9raXQvY29tcG9uZW50cy9zbGlkZXIvaGVscGVycy9zbGlkZXIta2V5LXN0ZXBzLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLFFBQVEsRUFDUixJQUFJLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3pDLE9BQU8sRUFDSCxrQkFBa0IsRUFDbEIsU0FBUyxFQUNULFFBQVEsRUFFUixrQkFBa0IsR0FDckIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUNILDJCQUEyQixFQUMzQiwyQkFBMkIsR0FDOUIsTUFBTSxxQkFBcUIsQ0FBQztBQUU3QixPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQzs7OztBQVd2RCxNQUFNLE9BQU8sMEJBQ1QsU0FBUSxrQkFBMEI7SUFzQmxDLFlBSUksT0FBeUIsRUFDRSxHQUFzQixFQUNaLEVBQWdDLEVBRXBELE1BQTBCO1FBRTNDLEtBQUssQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFKaUIsT0FBRSxHQUFGLEVBQUUsQ0FBOEI7UUFFcEQsV0FBTSxHQUFOLE1BQU0sQ0FBb0I7SUFHL0MsQ0FBQztJQTNCRCxJQUFJLHNCQUFzQjtRQUN0QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQztJQUNoRSxDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1AsT0FBTyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQsSUFBSSxHQUFHO1FBQ0gsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFJLEdBQUc7UUFDSCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQWlCRCxrQkFBa0I7UUFDZCxJQUFJLENBQUMsS0FBSyxHQUFHLDJCQUEyQixDQUNwQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FDaEIsQ0FBQztJQUNOLENBQUM7SUFFUSxVQUFVLENBQUMsWUFBMkI7UUFDM0MsSUFBSSxZQUFZLEtBQUssSUFBSSxFQUFFO1lBQ3ZCLE9BQU87U0FDVjtRQUVELE1BQU0sbUJBQW1CLEdBQUcsUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV2RSxTQUFTO1lBQ0wsU0FBUyxDQUFDLE1BQU0sQ0FDWixZQUFZLEtBQUssbUJBQW1CLEVBQ3BDLDJGQUEyRixDQUM5RixDQUFDO1FBRU4sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVTLGdCQUFnQjtRQUN0QixPQUFPLENBQUMsQ0FBQztJQUNiLENBQUM7SUFFTyxzQkFBc0IsQ0FBQyxZQUFvQjtRQUMvQyxNQUFNLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDL0IsTUFBTSxrQkFBa0IsR0FBRywyQkFBMkIsQ0FDbEQsWUFBWSxFQUNaLElBQUksQ0FBQyxRQUFRLENBQ2hCLENBQUM7UUFFRixPQUFPLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0lBQzFELENBQUM7O3dIQXpFUSwwQkFBMEIsa0JBMEJ2QixTQUFTLHlDQUVULGlCQUFpQixhQUNqQixVQUFVLGFBQ1YsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDOzRHQTlCdkMsMEJBQTBCOzRGQUExQiwwQkFBMEI7a0JBVHRDLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUFFLDRCQUE0QjtvQkFDdEMsSUFBSSxFQUFFO3dCQUNGLHNCQUFzQixFQUFFLGtCQUFrQjt3QkFDMUMsc0JBQXNCLEVBQUUsS0FBSzt3QkFDN0Isc0JBQXNCLEVBQUUsS0FBSzt3QkFDN0IsWUFBWSxFQUFFLGtCQUFrQjtxQkFDbkM7aUJBQ0o7OzBCQXlCUSxRQUFROzswQkFDUixJQUFJOzswQkFDSixNQUFNOzJCQUFDLFNBQVM7OzBCQUVoQixNQUFNOzJCQUFDLGlCQUFpQjs7MEJBQ3hCLE1BQU07MkJBQUMsVUFBVTs7MEJBQ2pCLE1BQU07MkJBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDOzRDQXpCaEQsUUFBUTtzQkFEUCxLQUFLO2dCQWtDTixrQkFBa0I7c0JBRmpCLFlBQVk7dUJBQUMsT0FBTzs7c0JBQ3BCLFlBQVk7dUJBQUMsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgZm9yd2FyZFJlZixcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIFNlbGYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOZ0NvbnRyb2x9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7XG4gICAgQWJzdHJhY3RUdWlDb250cm9sLFxuICAgIHR1aUFzc2VydCxcbiAgICB0dWlDbGFtcCxcbiAgICBUdWlGb2N1c2FibGVFbGVtZW50QWNjZXNzb3IsXG4gICAgdHVpSXNOYXRpdmVGb2N1c2VkLFxufSBmcm9tICdAdGFpZ2EtdWkvY2RrJztcbmltcG9ydCB7VHVpS2V5U3RlcHN9IGZyb20gJ0B0YWlnYS11aS9raXQvdHlwZXMnO1xuaW1wb3J0IHtcbiAgICB0dWlLZXlTdGVwVmFsdWVUb1BlcmNlbnRhZ2UsXG4gICAgdHVpUGVyY2VudGFnZVRvS2V5U3RlcFZhbHVlLFxufSBmcm9tICdAdGFpZ2EtdWkva2l0L3V0aWxzJztcblxuaW1wb3J0IHtUdWlTbGlkZXJDb21wb25lbnR9IGZyb20gJy4uL3NsaWRlci5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2lucHV0W3R1aVNsaWRlcl1ba2V5U3RlcHNdJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbm93XSc6ICdzYWZlQ3VycmVudFZhbHVlJyxcbiAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtaW5dJzogJ21pbicsXG4gICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWF4XSc6ICdtYXgnLFxuICAgICAgICAnW2Rpc2FibGVkXSc6ICdjb21wdXRlZERpc2FibGVkJyxcbiAgICB9LFxufSlcbmV4cG9ydCBjbGFzcyBUdWlTbGlkZXJLZXlTdGVwc0RpcmVjdGl2ZVxuICAgIGV4dGVuZHMgQWJzdHJhY3RUdWlDb250cm9sPG51bWJlcj5cbiAgICBpbXBsZW1lbnRzIFR1aUZvY3VzYWJsZUVsZW1lbnRBY2Nlc3Nvclxue1xuICAgIEBJbnB1dCgpXG4gICAga2V5U3RlcHMhOiBUdWlLZXlTdGVwcztcblxuICAgIGdldCBuYXRpdmVGb2N1c2FibGVFbGVtZW50KCk6IEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWREaXNhYmxlZCA/IG51bGwgOiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZ2V0IGZvY3VzZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0dWlJc05hdGl2ZUZvY3VzZWQodGhpcy5uYXRpdmVGb2N1c2FibGVFbGVtZW50KTtcbiAgICB9XG5cbiAgICBnZXQgbWluKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleVN0ZXBzWzBdWzFdO1xuICAgIH1cblxuICAgIGdldCBtYXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5U3RlcHNbdGhpcy5rZXlTdGVwcy5sZW5ndGggLSAxXVsxXTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQE9wdGlvbmFsKClcbiAgICAgICAgQFNlbGYoKVxuICAgICAgICBASW5qZWN0KE5nQ29udHJvbClcbiAgICAgICAgY29udHJvbDogTmdDb250cm9sIHwgbnVsbCxcbiAgICAgICAgQEluamVjdChDaGFuZ2VEZXRlY3RvclJlZikgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSBwcml2YXRlIHJlYWRvbmx5IGVsOiBFbGVtZW50UmVmPEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gVHVpU2xpZGVyQ29tcG9uZW50KSlcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzbGlkZXI6IFR1aVNsaWRlckNvbXBvbmVudCxcbiAgICApIHtcbiAgICAgICAgc3VwZXIoY29udHJvbCwgY2RyKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdpbnB1dCcpXG4gICAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJylcbiAgICB1cGRhdGVDb250cm9sVmFsdWUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0dWlQZXJjZW50YWdlVG9LZXlTdGVwVmFsdWUoXG4gICAgICAgICAgICB0aGlzLnNsaWRlci52YWx1ZVBlcmNlbnRhZ2UsXG4gICAgICAgICAgICB0aGlzLmtleVN0ZXBzLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIG92ZXJyaWRlIHdyaXRlVmFsdWUoY29udHJvbFZhbHVlOiBudW1iZXIgfCBudWxsKTogdm9pZCB7XG4gICAgICAgIGlmIChjb250cm9sVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsYW1wZWRDb250cm9sVmFsdWUgPSB0dWlDbGFtcChjb250cm9sVmFsdWUsIHRoaXMubWluLCB0aGlzLm1heCk7XG5cbiAgICAgICAgbmdEZXZNb2RlICYmXG4gICAgICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIGNvbnRyb2xWYWx1ZSA9PT0gY2xhbXBlZENvbnRyb2xWYWx1ZSxcbiAgICAgICAgICAgICAgICAnXFxuW1NsaWRlcktleVN0ZXBzXTogWW91IGNhbm5vdCBwcm9ncmFtbWF0aWNhbGx5IHNldCB2YWx1ZSB3aGljaCBpcyBsZXNzL21vcmUgdGhhbiBtaW4vbWF4JyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zbGlkZXIudmFsdWUgPSB0aGlzLnRyYW5zZm9ybVRvTmF0aXZlVmFsdWUoY2xhbXBlZENvbnRyb2xWYWx1ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEZhbGxiYWNrVmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm1Ub05hdGl2ZVZhbHVlKGNvbnRyb2xWYWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuc2xpZGVyO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZVBlcmNlbnRhZ2UgPSB0dWlLZXlTdGVwVmFsdWVUb1BlcmNlbnRhZ2UoXG4gICAgICAgICAgICBjb250cm9sVmFsdWUsXG4gICAgICAgICAgICB0aGlzLmtleVN0ZXBzLFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiAobmV3VmFsdWVQZXJjZW50YWdlICogKG1heCAtIG1pbikpIC8gMTAwICsgbWluO1xuICAgIH1cbn1cbiJdfQ==