import { ElementRef, Inject, Injectable } from '@angular/core';
import { TUI_SCROLL_REF, tuiScrollFrom, tuiTypedFromEvent } from '@taiga-ui/cdk';
import { EMPTY, Observable } from 'rxjs';
import { distinctUntilChanged, endWith, filter, map, scan, share, startWith, switchMap, takeUntil, takeWhile, tap, } from 'rxjs/operators';
import { TUI_PULL_TO_REFRESH_COMPONENT, TUI_PULL_TO_REFRESH_LOADED, TUI_PULL_TO_REFRESH_THRESHOLD, } from './pull-to-refresh.providers';
import * as i0 from "@angular/core";
import * as i1 from "rxjs";
export const MICRO_OFFSET = Math.pow(10, -6);
export class TuiPullToRefreshService extends Observable {
    constructor(el, scrollRef, loaded$, threshold, component) {
        super(subscriber => (component ? this.pulling$ : EMPTY).subscribe(subscriber));
        this.el = el;
        this.scrollRef = scrollRef;
        this.loaded$ = loaded$;
        this.threshold = threshold;
        // Hack for iOS to determine if pulling stopped due to scroll
        // because Safari does not support `touch-action: pan-down`
        this.touched = false;
        this.pulling$ = this.loaded$.pipe(startWith(null), switchMap(() => tuiTypedFromEvent(this.element, 'touchstart', { passive: true }).pipe(filter(() => !this.scrollTop), map(({ touches }) => touches[0].clientY), switchMap(start => tuiTypedFromEvent(this.element, 'touchmove').pipe(tap(() => {
            this.touched = true;
        }), map(({ touches }) => touches[0].clientY - start), filter(distance => distance > 0), takeUntil(tuiTypedFromEvent(this.element, 'touchend').pipe(tap(() => {
            this.touched = false;
        }))), takeUntil(tuiScrollFrom(this.scrollRef.nativeElement)), endWith(0))), scan((prev, current) => !current && !this.touched && prev > this.threshold
            ? this.threshold
            : current + current * MICRO_OFFSET, 0), takeWhile(distance => distance !== this.threshold, true), startWith(0))), distinctUntilChanged(), share());
    }
    get element() {
        return this.el.nativeElement;
    }
    get scrollTop() {
        return this.scrollRef.nativeElement.scrollTop;
    }
}
TuiPullToRefreshService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPullToRefreshService, deps: [{ token: ElementRef }, { token: TUI_SCROLL_REF }, { token: TUI_PULL_TO_REFRESH_LOADED }, { token: TUI_PULL_TO_REFRESH_THRESHOLD }, { token: TUI_PULL_TO_REFRESH_COMPONENT }], target: i0.ɵɵFactoryTarget.Injectable });
TuiPullToRefreshService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPullToRefreshService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiPullToRefreshService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [TUI_SCROLL_REF]
                }] }, { type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [TUI_PULL_TO_REFRESH_LOADED]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_PULL_TO_REFRESH_THRESHOLD]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TUI_PULL_TO_REFRESH_COMPONENT]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVsbC10by1yZWZyZXNoLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hZGRvbi1tb2JpbGUvY29tcG9uZW50cy9wdWxsLXRvLXJlZnJlc2gvcHVsbC10by1yZWZyZXNoLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBQyxjQUFjLEVBQUUsYUFBYSxFQUFFLGlCQUFpQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQy9FLE9BQU8sRUFBQyxLQUFLLEVBQUUsVUFBVSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ3ZDLE9BQU8sRUFDSCxvQkFBb0IsRUFDcEIsT0FBTyxFQUNQLE1BQU0sRUFDTixHQUFHLEVBQ0gsSUFBSSxFQUNKLEtBQUssRUFDTCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsR0FBRyxHQUNOLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEIsT0FBTyxFQUNILDZCQUE2QixFQUM3QiwwQkFBMEIsRUFDMUIsNkJBQTZCLEdBQ2hDLE1BQU0sNkJBQTZCLENBQUM7OztBQUVyQyxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUcsU0FBQSxFQUFFLEVBQUksQ0FBQyxDQUFDLENBQUEsQ0FBQztBQUdyQyxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsVUFBa0I7SUE0QzNELFlBQ3lDLEVBQTJCLEVBQ3ZCLFNBQWtDLEVBQ3RCLE9BQTRCLEVBQ3pCLFNBQWlCLEVBQ2xDLFNBQWtCO1FBRXpELEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQU4xQyxPQUFF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b250ZW50IjpbImltcG9ydCB7RWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7VFVJX1NDUk9MTF9SRUYsIHR1aVNjcm9sbEZyb20sIHR1aVR5cGVkRnJvbUV2ZW50fSBmcm9tICdAdGFpZ2EtdWkvY2RrJztcbmltcG9ydCB7RU1QVFksIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgICBlbmRXaXRoLFxuICAgIGZpbHRlcixcbiAgICBtYXAsXG4gICAgc2NhbixcbiAgICBzaGFyZSxcbiAgICBzdGFydFdpdGgsXG4gICAgc3dpdGNoTWFwLFxuICAgIHRha2VVbnRpbCxcbiAgICB0YWtlV2hpbGUsXG4gICAgdGFwLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7XG4gICAgVFVJX1BVTExfVE9fUkVGUkVTSF9DT01QT05FTlQsXG4gICAgVFVJX1BVTExfVE9fUkVGUkVTSF9MT0FERUQsXG4gICAgVFVJX1BVTExfVE9fUkVGUkVTSF9USFJFU0hPTEQsXG59IGZyb20gJy4vcHVsbC10by1yZWZyZXNoLnByb3ZpZGVycyc7XG5cbmV4cG9ydCBjb25zdCBNSUNST19PRkZTRVQgPSAxMCAqKiAtNjtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFR1aVB1bGxUb1JlZnJlc2hTZXJ2aWNlIGV4dGVuZHMgT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICAvLyBIYWNrIGZvciBpT1MgdG8gZGV0ZXJtaW5lIGlmIHB1bGxpbmcgc3RvcHBlZCBkdWUgdG8gc2Nyb2xsXG4gICAgLy8gYmVjYXVzZSBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBgdG91Y2gtYWN0aW9uOiBwYW4tZG93bmBcbiAgICBwcml2YXRlIHRvdWNoZWQgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHVsbGluZyQgPSB0aGlzLmxvYWRlZCQucGlwZShcbiAgICAgICAgc3RhcnRXaXRoKG51bGwpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cbiAgICAgICAgICAgIHR1aVR5cGVkRnJvbUV2ZW50KHRoaXMuZWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB7cGFzc2l2ZTogdHJ1ZX0pLnBpcGUoXG4gICAgICAgICAgICAgICAgZmlsdGVyKCgpID0+ICF0aGlzLnNjcm9sbFRvcCksXG4gICAgICAgICAgICAgICAgbWFwKCh7dG91Y2hlc30pID0+IHRvdWNoZXNbMF0uY2xpZW50WSksXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKHN0YXJ0ID0+XG4gICAgICAgICAgICAgICAgICAgIHR1aVR5cGVkRnJvbUV2ZW50KHRoaXMuZWxlbWVudCwgJ3RvdWNobW92ZScpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXAoKCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcCgoe3RvdWNoZXN9KSA9PiB0b3VjaGVzWzBdLmNsaWVudFkgLSBzdGFydCksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIoZGlzdGFuY2UgPT4gZGlzdGFuY2UgPiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dWlUeXBlZEZyb21FdmVudCh0aGlzLmVsZW1lbnQsICd0b3VjaGVuZCcpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcCgoKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwodHVpU2Nyb2xsRnJvbSh0aGlzLnNjcm9sbFJlZi5uYXRpdmVFbGVtZW50KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRXaXRoKDApLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc2NhbihcbiAgICAgICAgICAgICAgICAgICAgKHByZXYsIGN1cnJlbnQpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudCAmJiAhdGhpcy50b3VjaGVkICYmIHByZXYgPiB0aGlzLnRocmVzaG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy50aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnQgKyBjdXJyZW50ICogTUlDUk9fT0ZGU0VULFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGFrZVdoaWxlKGRpc3RhbmNlID0+IGRpc3RhbmNlICE9PSB0aGlzLnRocmVzaG9sZCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgc3RhcnRXaXRoKDApLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgICAgc2hhcmUoKSxcbiAgICApO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoRWxlbWVudFJlZikgcHJpdmF0ZSByZWFkb25seSBlbDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIEBJbmplY3QoVFVJX1NDUk9MTF9SRUYpIHByaXZhdGUgcmVhZG9ubHkgc2Nyb2xsUmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgQEluamVjdChUVUlfUFVMTF9UT19SRUZSRVNIX0xPQURFRCkgcHJpdmF0ZSByZWFkb25seSBsb2FkZWQkOiBPYnNlcnZhYmxlPHVua25vd24+LFxuICAgICAgICBASW5qZWN0KFRVSV9QVUxMX1RPX1JFRlJFU0hfVEhSRVNIT0xEKSBwcml2YXRlIHJlYWRvbmx5IHRocmVzaG9sZDogbnVtYmVyLFxuICAgICAgICBASW5qZWN0KFRVSV9QVUxMX1RPX1JFRlJFU0hfQ09NUE9ORU5UKSBjb21wb25lbnQ6IHVua25vd24sXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHN1YnNjcmliZXIgPT4gKGNvbXBvbmVudCA/IHRoaXMucHVsbGluZyQgOiBFTVBUWSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBlbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBzY3JvbGxUb3AoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIH1cbn1cbiJdfQ==