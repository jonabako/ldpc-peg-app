import { Directive, ElementRef, Inject, Input, Renderer2, Self } from '@angular/core';
import { ALWAYS_FALSE_HANDLER, ALWAYS_TRUE_HANDLER, TuiDestroyService, TuiDirectiveStylesService, tuiTypedFromEvent, } from '@taiga-ui/cdk';
import { race, timer } from 'rxjs';
import { map, mergeMap, switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { RIPPLE_OFF, TUI_RIPPLE_END, TUI_RIPPLE_PROVIDERS, TUI_RIPPLE_START, } from './ripple.providers';
import { TuiRippleStylesComponent } from './ripple-styles.component';
import * as i0 from "@angular/core";
import * as i1 from "@taiga-ui/cdk";
import * as i2 from "rxjs";
const TOUCH_MOVE_DELAY = 100;
export class TuiRippleDirective {
    constructor({ nativeElement }, directiveStyles, renderer, destroy$, start$, end$) {
        directiveStyles.addComponent(TuiRippleStylesComponent);
        const touchEnd$ = tuiTypedFromEvent(nativeElement, 'touchend');
        const touchMove$ = tuiTypedFromEvent(nativeElement, 'touchmove');
        end$.subscribe(element => {
            renderer.removeChild(nativeElement, element);
        });
        start$
            .pipe(mergeMap(ripple => {
            const animationEndOn$ = tuiTypedFromEvent(ripple, 'animationend');
            return race(timer(TOUCH_MOVE_DELAY).pipe(map(ALWAYS_FALSE_HANDLER)), touchEnd$.pipe(map(ALWAYS_TRUE_HANDLER))).pipe(take(1), 
            // eslint-disable-next-line rxjs/no-unsafe-takeuntil
            takeUntil(touchMove$), tap(() => {
                renderer.setStyle(ripple, 'background', this.tuiRipple || null);
                renderer.appendChild(nativeElement, ripple);
            }), switchMap(isTap => isTap
                ? animationEndOn$
                : race(touchEnd$.pipe(switchMap(() => animationEndOn$)), animationEndOn$.pipe(switchMap(() => touchEnd$)))), map(() => ripple));
        }), takeUntil(destroy$))
            .subscribe(element => {
            renderer.setStyle(element, 'animationName', RIPPLE_OFF);
        });
    }
}
TuiRippleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRippleDirective, deps: [{ token: ElementRef }, { token: TuiDirectiveStylesService }, { token: Renderer2 }, { token: TuiDestroyService, self: true }, { token: TUI_RIPPLE_START }, { token: TUI_RIPPLE_END }], target: i0.ɵɵFactoryTarget.Directive });
TuiRippleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.17", type: TuiRippleDirective, selector: "[tuiRipple]", inputs: { tuiRipple: "tuiRipple" }, providers: TUI_RIPPLE_PROVIDERS, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiRippleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[tuiRipple]',
                    providers: TUI_RIPPLE_PROVIDERS,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i1.TuiDirectiveStylesService, decorators: [{
                    type: Inject,
                    args: [TuiDirectiveStylesService]
                }] }, { type: i0.Renderer2, decorators: [{
                    type: Inject,
                    args: [Renderer2]
                }] }, { type: i1.TuiDestroyService, decorators: [{
                    type: Self
                }, {
                    type: Inject,
                    args: [TuiDestroyService]
                }] }, { type: i2.Observable, decorators: [{
                    type: Inject,
                    args: [TUI_RIPPLE_START]
                }] }, { type: i2.Observable, decorators: [{
                    type: Inject,
                    args: [TUI_RIPPLE_END]
                }] }]; }, propDecorators: { tuiRipple: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmlwcGxlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FkZG9uLW1vYmlsZS9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNwRixPQUFPLEVBQ0gsb0JBQW9CLEVBQ3BCLG1CQUFtQixFQUNuQixpQkFBaUIsRUFDakIseUJBQXlCLEVBQ3pCLGlCQUFpQixHQUNwQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQWEsSUFBSSxFQUFFLEtBQUssRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUU5RSxPQUFPLEVBQ0gsVUFBVSxFQUNWLGNBQWMsRUFDZCxvQkFBb0IsRUFDcEIsZ0JBQWdCLEdBQ25CLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sMkJBQTJCLENBQUM7Ozs7QUFFbkUsTUFBTSxnQkFBZ0IsR0FBRyxHQUFHLENBQUM7QUFNN0IsTUFBTSxPQUFPLGtCQUFrQjtJQUkzQixZQUN3QixFQUFDLGFBQWEsRUFBMEIsRUFDekIsZUFBMEMsRUFDMUQsUUFBbUIsRUFDSCxRQUEyQixFQUNwQyxNQUErQixFQUNqQyxJQUE2QjtRQUVyRCxlQUFlLENBQUMsWUFBWSxDQUFDLHdCQUF3QixDQUFDLENBQUM7UUFFdkQsTUFBTSxTQUFTLEdBQUcsaUJBQWlCLENBQUMsYUFBYSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sVUFBVSxHQUFHLGlCQUFpQixDQUFDLGFBQWEsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUVqRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3JCLFFBQVEsQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2pELENBQUMsQ0FBQyxDQUFDO1FBQ0gsTUFBTTthQUNELElBQUksQ0FDRCxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDZCxNQUFNLGVBQWUsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsY0FBYyxDQUFDLENBQUM7WUFFbEUsT0FBTyxJQUFJLENBQ1AsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLEVBQ3ZELFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FDM0MsQ0FBQyxJQUFJLENBQ0YsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNQLG9EQUFvRDtZQUNwRCxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQ3JCLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ0wsUUFBUSxDQUFDLFFBQVEsQ0FDYixNQUFNLEVBQ04sWUFBWSxFQUNaLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUN6QixDQUFDO2dCQUNGLFFBQVEsQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ2hELENBQUMsQ0FBQyxFQUNGLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUNkLEtBQUs7Z0JBQ0QsQ0FBQyxDQUFDLGVBQWU7Z0JBQ2pCLENBQUMsQ0FBQyxJQUFJLENBQ0EsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLENBQUMsRUFDaEQsZUFBZSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FDbkQsQ0FDVixFQUNELEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FDcEIsQ0FBQztRQUNOLENBQUMsQ0FBQyxFQUNGLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FDdEI7YUFDQSxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDakIsUUFBUSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsZUFBZSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQzVELENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQzs7Z0hBeERRLGtCQUFrQixrQkFLZixVQUFVLGFBQ1YseUJBQXlCLGFBQ3pCLFNBQVMsYUFDRCxpQkFBaUIseUJBQ3pCLGdCQUFnQixhQUNoQixjQUFjO29HQVZqQixrQkFBa0IsMEVBRmhCLG9CQUFvQjs0RkFFdEIsa0JBQWtCO2tCQUo5QixTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxhQUFhO29CQUN2QixTQUFTLEVBQUUsb0JBQW9CO2lCQUNsQzs7MEJBTVEsTUFBTTsyQkFBQyxVQUFVOzswQkFDakIsTUFBTTsyQkFBQyx5QkFBeUI7OzBCQUNoQyxNQUFNOzJCQUFDLFNBQVM7OzBCQUNoQixJQUFJOzswQkFBSSxNQUFNOzJCQUFDLGlCQUFpQjs7MEJBQ2hDLE1BQU07MkJBQUMsZ0JBQWdCOzswQkFDdkIsTUFBTTsyQkFBQyxjQUFjOzRDQVIxQixTQUFTO3NCQURSLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0LCBJbnB1dCwgUmVuZGVyZXIyLCBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgQUxXQVlTX0ZBTFNFX0hBTkRMRVIsXG4gICAgQUxXQVlTX1RSVUVfSEFORExFUixcbiAgICBUdWlEZXN0cm95U2VydmljZSxcbiAgICBUdWlEaXJlY3RpdmVTdHlsZXNTZXJ2aWNlLFxuICAgIHR1aVR5cGVkRnJvbUV2ZW50LFxufSBmcm9tICdAdGFpZ2EtdWkvY2RrJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgcmFjZSwgdGltZXJ9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHttYXAsIG1lcmdlTWFwLCBzd2l0Y2hNYXAsIHRha2UsIHRha2VVbnRpbCwgdGFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7XG4gICAgUklQUExFX09GRixcbiAgICBUVUlfUklQUExFX0VORCxcbiAgICBUVUlfUklQUExFX1BST1ZJREVSUyxcbiAgICBUVUlfUklQUExFX1NUQVJULFxufSBmcm9tICcuL3JpcHBsZS5wcm92aWRlcnMnO1xuaW1wb3J0IHtUdWlSaXBwbGVTdHlsZXNDb21wb25lbnR9IGZyb20gJy4vcmlwcGxlLXN0eWxlcy5jb21wb25lbnQnO1xuXG5jb25zdCBUT1VDSF9NT1ZFX0RFTEFZID0gMTAwO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t0dWlSaXBwbGVdJyxcbiAgICBwcm92aWRlcnM6IFRVSV9SSVBQTEVfUFJPVklERVJTLFxufSlcbmV4cG9ydCBjbGFzcyBUdWlSaXBwbGVEaXJlY3RpdmUge1xuICAgIEBJbnB1dCgpXG4gICAgdHVpUmlwcGxlPzogc3RyaW5nIHwgJyc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSB7bmF0aXZlRWxlbWVudH06IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICBASW5qZWN0KFR1aURpcmVjdGl2ZVN0eWxlc1NlcnZpY2UpIGRpcmVjdGl2ZVN0eWxlczogVHVpRGlyZWN0aXZlU3R5bGVzU2VydmljZSxcbiAgICAgICAgQEluamVjdChSZW5kZXJlcjIpIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIEBTZWxmKCkgQEluamVjdChUdWlEZXN0cm95U2VydmljZSkgZGVzdHJveSQ6IFR1aURlc3Ryb3lTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KFRVSV9SSVBQTEVfU1RBUlQpIHN0YXJ0JDogT2JzZXJ2YWJsZTxIVE1MRWxlbWVudD4sXG4gICAgICAgIEBJbmplY3QoVFVJX1JJUFBMRV9FTkQpIGVuZCQ6IE9ic2VydmFibGU8RXZlbnRUYXJnZXQ+LFxuICAgICkge1xuICAgICAgICBkaXJlY3RpdmVTdHlsZXMuYWRkQ29tcG9uZW50KFR1aVJpcHBsZVN0eWxlc0NvbXBvbmVudCk7XG5cbiAgICAgICAgY29uc3QgdG91Y2hFbmQkID0gdHVpVHlwZWRGcm9tRXZlbnQobmF0aXZlRWxlbWVudCwgJ3RvdWNoZW5kJyk7XG4gICAgICAgIGNvbnN0IHRvdWNoTW92ZSQgPSB0dWlUeXBlZEZyb21FdmVudChuYXRpdmVFbGVtZW50LCAndG91Y2htb3ZlJyk7XG5cbiAgICAgICAgZW5kJC5zdWJzY3JpYmUoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICByZW5kZXJlci5yZW1vdmVDaGlsZChuYXRpdmVFbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0JFxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgbWVyZ2VNYXAocmlwcGxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRW5kT24kID0gdHVpVHlwZWRGcm9tRXZlbnQocmlwcGxlLCAnYW5pbWF0aW9uZW5kJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcihUT1VDSF9NT1ZFX0RFTEFZKS5waXBlKG1hcChBTFdBWVNfRkFMU0VfSEFORExFUikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hFbmQkLnBpcGUobWFwKEFMV0FZU19UUlVFX0hBTkRMRVIpKSxcbiAgICAgICAgICAgICAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByeGpzL25vLXVuc2FmZS10YWtldW50aWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0b3VjaE1vdmUkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpcHBsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR1aVJpcHBsZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuYXBwZW5kQ2hpbGQobmF0aXZlRWxlbWVudCwgcmlwcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoTWFwKGlzVGFwID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhbmltYXRpb25FbmRPbiRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaEVuZCQucGlwZShzd2l0Y2hNYXAoKCkgPT4gYW5pbWF0aW9uRW5kT24kKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVuZE9uJC5waXBlKHN3aXRjaE1hcCgoKSA9PiB0b3VjaEVuZCQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcCgoKSA9PiByaXBwbGUpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbChkZXN0cm95JCksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsICdhbmltYXRpb25OYW1lJywgUklQUExFX09GRik7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=