import { ElementRef, InjectionToken, Renderer2 } from '@angular/core';
import { TUI_IS_IOS, TUI_TOUCH_SUPPORTED, TuiDestroyService, tuiIsPresent, tuiPx, tuiTypedFromEvent, } from '@taiga-ui/cdk';
import { EMPTY } from 'rxjs';
import { filter, map, takeUntil } from 'rxjs/operators';
export const RIPPLE_ON = 'tuiRippleOn';
export const RIPPLE_OFF = 'tuiRippleOff';
/**
 * Stream of ripple elements to add
 */
export const TUI_RIPPLE_START = new InjectionToken('[TUI_RIPPLE_START]');
/**
 * Stream of ripple elements to remove
 */
export const TUI_RIPPLE_END = new InjectionToken('[TUI_RIPPLE_END]');
export const TUI_RIPPLE_PROVIDERS = [
    TuiDestroyService,
    {
        provide: TUI_RIPPLE_START,
        deps: [TUI_TOUCH_SUPPORTED, TUI_IS_IOS, ElementRef, Renderer2],
        useFactory: (touchSupported, isIOS, { nativeElement }, renderer) => isIOS || !touchSupported
            ? EMPTY
            : tuiTypedFromEvent(nativeElement, 'touchstart').pipe(map(({ touches }) => {
                const { clientX, clientY } = touches[touches.length - 1];
                const { width, height, top, left } = nativeElement.getBoundingClientRect();
                const radius = Math.sqrt(width * width + height * height);
                const dimension = radius * 2;
                const x = clientX - left - radius;
                const y = clientY - top - radius;
                const ripple = renderer.createElement('div');
                renderer.addClass(ripple, 'tui-ripple');
                renderer.setAttribute(ripple, 'style', `width: ${tuiPx(dimension)}; height: ${tuiPx(dimension)}; left: ${tuiPx(x)}; top: ${tuiPx(y)}; animation-name: ${RIPPLE_ON};`);
                return ripple;
            })),
    },
    {
        provide: TUI_RIPPLE_END,
        deps: [TUI_TOUCH_SUPPORTED, TUI_IS_IOS, ElementRef, TuiDestroyService],
        useFactory: (touchSupported, isIOS, { nativeElement }, destroy$) => isIOS || !touchSupported
            ? EMPTY
            : tuiTypedFromEvent(nativeElement, 'animationend').pipe(filter(({ animationName }) => animationName === RIPPLE_OFF), map(({ target }) => target), filter(tuiIsPresent), takeUntil(destroy$)),
    },
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmlwcGxlLnByb3ZpZGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FkZG9uLW1vYmlsZS9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUucHJvdmlkZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxVQUFVLEVBQUUsY0FBYyxFQUFZLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM5RSxPQUFPLEVBQ0gsVUFBVSxFQUNWLG1CQUFtQixFQUNuQixpQkFBaUIsRUFDakIsWUFBWSxFQUNaLEtBQUssRUFDTCxpQkFBaUIsR0FDcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLEtBQUssRUFBYSxNQUFNLE1BQU0sQ0FBQztBQUN2QyxPQUFPLEVBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUV0RCxNQUFNLENBQUMsTUFBTSxTQUFTLEdBQUcsYUFBYSxDQUFDO0FBQ3ZDLE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxjQUFjLENBQUM7QUFFekM7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLGNBQWMsQ0FDOUMsb0JBQW9CLENBQ3ZCLENBQUM7QUFFRjs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxJQUFJLGNBQWMsQ0FDNUMsa0JBQWtCLENBQ3JCLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBZTtJQUM1QyxpQkFBaUI7SUFDakI7UUFDSSxPQUFPLEVBQUUsZ0JBQWdCO1FBQ3pCLElBQUksRUFBRSxDQUFDLG1CQUFtQixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDO1FBQzlELFVBQVUsRUFBRSxDQUNSLGNBQXVCLEVBQ3ZCLEtBQWMsRUFDZCxFQUFDLGFBQWEsRUFBMEIsRUFDeEMsUUFBbUIsRUFDSSxFQUFFLENBQ3pCLEtBQUssSUFBSSxDQUFDLGNBQWM7WUFDcEIsQ0FBQyxDQUFDLEtBQUs7WUFDUCxDQUFDLENBQUMsaUJBQWlCLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FDL0MsR0FBRyxDQUFDLENBQUMsRUFBQyxPQUFPLEVBQUMsRUFBRSxFQUFFO2dCQUNkLE1BQU0sRUFBQyxPQUFPLEVBQUUsT0FBTyxFQUFDLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZELE1BQU0sRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUMsR0FDNUIsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUM7Z0JBQzFDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUM7Z0JBQzFELE1BQU0sU0FBUyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7Z0JBQzdCLE1BQU0sQ0FBQyxHQUFHLE9BQU8sR0FBRyxJQUFJLEdBQUcsTUFBTSxDQUFDO2dCQUNsQyxNQUFNLENBQUMsR0FBRyxPQUFPLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQztnQkFDakMsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFFN0MsUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0JBQ3hDLFFBQVEsQ0FBQyxZQUFZLENBQ2pCLE1BQU0sRUFDTixPQUFPLEVBQ1AsVUFBVSxLQUFLLENBQUMsU0FBUyxDQUFDLGFBQWEsS0FBSyxDQUN4QyxTQUFTLENBQ1osV0FBVyxLQUFLLENBQUMsQ0FBQyxDQUFDLFVBQVUsS0FBSyxDQUMvQixDQUFDLENBQ0oscUJBQXFCLFNBQVMsR0FBRyxDQUNyQyxDQUFDO2dCQUVGLE9BQU8sTUFBTSxDQUFDO1lBQ2xCLENBQUMsQ0FBQyxDQUNMO0tBQ2Q7SUFDRDtRQUNJLE9BQU8sRUFBRSxjQUFjO1FBQ3ZCLElBQUksRUFBRSxDQUFDLG1CQUFtQixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsaUJBQWlCLENBQUM7UUFDdEUsVUFBVSxFQUFFLENBQ1IsY0FBdUIsRUFDdkIsS0FBYyxFQUNkLEVBQUMsYUFBYSxFQUEwQixFQUN4QyxRQUEwQixFQUNILEVBQUUsQ0FDekIsS0FBSyxJQUFJLENBQUMsY0FBYztZQUNwQixDQUFDLENBQUMsS0FBSztZQUNQLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUNqRCxNQUFNLENBQUMsQ0FBQyxFQUFDLGFBQWEsRUFBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLEtBQUssVUFBVSxDQUFDLEVBQ3pELEdBQUcsQ0FBQyxDQUFDLEVBQUMsTUFBTSxFQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUN6QixNQUFNLENBQUMsWUFBWSxDQUFDLEVBQ3BCLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FDdEI7S0FDZDtDQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0VsZW1lbnRSZWYsIEluamVjdGlvblRva2VuLCBQcm92aWRlciwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgVFVJX0lTX0lPUyxcbiAgICBUVUlfVE9VQ0hfU1VQUE9SVEVELFxuICAgIFR1aURlc3Ryb3lTZXJ2aWNlLFxuICAgIHR1aUlzUHJlc2VudCxcbiAgICB0dWlQeCxcbiAgICB0dWlUeXBlZEZyb21FdmVudCxcbn0gZnJvbSAnQHRhaWdhLXVpL2Nkayc7XG5pbXBvcnQge0VNUFRZLCBPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZmlsdGVyLCBtYXAsIHRha2VVbnRpbH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgY29uc3QgUklQUExFX09OID0gJ3R1aVJpcHBsZU9uJztcbmV4cG9ydCBjb25zdCBSSVBQTEVfT0ZGID0gJ3R1aVJpcHBsZU9mZic7XG5cbi8qKlxuICogU3RyZWFtIG9mIHJpcHBsZSBlbGVtZW50cyB0byBhZGRcbiAqL1xuZXhwb3J0IGNvbnN0IFRVSV9SSVBQTEVfU1RBUlQgPSBuZXcgSW5qZWN0aW9uVG9rZW48T2JzZXJ2YWJsZTxIVE1MRWxlbWVudD4+KFxuICAgICdbVFVJX1JJUFBMRV9TVEFSVF0nLFxuKTtcblxuLyoqXG4gKiBTdHJlYW0gb2YgcmlwcGxlIGVsZW1lbnRzIHRvIHJlbW92ZVxuICovXG5leHBvcnQgY29uc3QgVFVJX1JJUFBMRV9FTkQgPSBuZXcgSW5qZWN0aW9uVG9rZW48T2JzZXJ2YWJsZTxIVE1MRWxlbWVudD4+KFxuICAgICdbVFVJX1JJUFBMRV9FTkRdJyxcbik7XG5cbmV4cG9ydCBjb25zdCBUVUlfUklQUExFX1BST1ZJREVSUzogUHJvdmlkZXJbXSA9IFtcbiAgICBUdWlEZXN0cm95U2VydmljZSxcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IFRVSV9SSVBQTEVfU1RBUlQsXG4gICAgICAgIGRlcHM6IFtUVUlfVE9VQ0hfU1VQUE9SVEVELCBUVUlfSVNfSU9TLCBFbGVtZW50UmVmLCBSZW5kZXJlcjJdLFxuICAgICAgICB1c2VGYWN0b3J5OiAoXG4gICAgICAgICAgICB0b3VjaFN1cHBvcnRlZDogYm9vbGVhbixcbiAgICAgICAgICAgIGlzSU9TOiBib29sZWFuLFxuICAgICAgICAgICAge25hdGl2ZUVsZW1lbnR9OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgICk6IE9ic2VydmFibGU8SFRNTEVsZW1lbnQ+ID0+XG4gICAgICAgICAgICBpc0lPUyB8fCAhdG91Y2hTdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICA/IEVNUFRZXG4gICAgICAgICAgICAgICAgOiB0dWlUeXBlZEZyb21FdmVudChuYXRpdmVFbGVtZW50LCAndG91Y2hzdGFydCcpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgICAgbWFwKCh7dG91Y2hlc30pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gdG91Y2hlc1t0b3VjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0fSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHJhZGl1cyAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdCAtIHJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IGNsaWVudFkgLSB0b3AgLSByYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpcHBsZSA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLmFkZENsYXNzKHJpcHBsZSwgJ3R1aS1yaXBwbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlwcGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB3aWR0aDogJHt0dWlQeChkaW1lbnNpb24pfTsgaGVpZ2h0OiAke3R1aVB4KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9OyBsZWZ0OiAke3R1aVB4KHgpfTsgdG9wOiAke3R1aVB4KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfTsgYW5pbWF0aW9uLW5hbWU6ICR7UklQUExFX09OfTtgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaXBwbGU7XG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICApLFxuICAgIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiBUVUlfUklQUExFX0VORCxcbiAgICAgICAgZGVwczogW1RVSV9UT1VDSF9TVVBQT1JURUQsIFRVSV9JU19JT1MsIEVsZW1lbnRSZWYsIFR1aURlc3Ryb3lTZXJ2aWNlXSxcbiAgICAgICAgdXNlRmFjdG9yeTogKFxuICAgICAgICAgICAgdG91Y2hTdXBwb3J0ZWQ6IGJvb2xlYW4sXG4gICAgICAgICAgICBpc0lPUzogYm9vbGVhbixcbiAgICAgICAgICAgIHtuYXRpdmVFbGVtZW50fTogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgICAgICBkZXN0cm95JDogT2JzZXJ2YWJsZTx2b2lkPixcbiAgICAgICAgKTogT2JzZXJ2YWJsZTxFdmVudFRhcmdldD4gPT5cbiAgICAgICAgICAgIGlzSU9TIHx8ICF0b3VjaFN1cHBvcnRlZFxuICAgICAgICAgICAgICAgID8gRU1QVFlcbiAgICAgICAgICAgICAgICA6IHR1aVR5cGVkRnJvbUV2ZW50KG5hdGl2ZUVsZW1lbnQsICdhbmltYXRpb25lbmQnKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcigoe2FuaW1hdGlvbk5hbWV9KSA9PiBhbmltYXRpb25OYW1lID09PSBSSVBQTEVfT0ZGKSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXAoKHt0YXJnZXR9KSA9PiB0YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcih0dWlJc1ByZXNlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChkZXN0cm95JCksXG4gICAgICAgICAgICAgICAgICApLFxuICAgIH0sXG5dO1xuIl19