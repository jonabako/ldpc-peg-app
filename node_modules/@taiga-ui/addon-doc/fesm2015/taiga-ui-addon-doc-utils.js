import MarkdownIt from 'markdown-it';
import { __awaiter } from 'tslib';

function tuiCoerceValueIsTrue(value) {
    return (value === null || value === void 0 ? void 0 : value.toString()) === 'true';
}

function isEmptyParamValue(value) {
    return ['undefined', 'null', 'NaN'].includes(value);
}
function isBooleanParamValue(value) {
    return value === 'true' || value === 'false';
}
function isNumberParamValue(value) {
    return !!value.trim() && !Number.isNaN(Number(value)) && !value.startsWith('+');
}
function isPossibleArray(value) {
    return value.startsWith('[') && value.endsWith(']');
}
function isPossibleObject(value) {
    return value.startsWith('{') && value.endsWith('}');
}
function tuiCoerceValue(value) {
    const prepared = String(value).trim();
    if (isEmptyParamValue(prepared)) {
        return null;
    }
    if (isBooleanParamValue(prepared)) {
        return String(prepared) === 'true';
    }
    if (isNumberParamValue(prepared)) {
        return Number(prepared);
    }
    const decodedValue = decodeURIComponent(prepared);
    try {
        return isPossibleArray(decodedValue) || isPossibleObject(decodedValue)
            ? JSON.parse(decodedValue)
            : decodedValue;
    }
    catch (_a) {
        return decodedValue;
    }
}

function tuiGenerateRoutes(type) {
    return [
        {
            path: '',
            component: type,
            children: [
                {
                    path: ':tab',
                    component: type,
                },
            ],
        },
    ];
}

function inspectArray(array, depth) {
    if (depth === 0) {
        return '[…]';
    }
    let result = '';
    let first = true;
    for (let index = 0; index < array.length; index++) {
        if (first) {
            first = false;
        }
        else {
            result += ', ';
        }
        result += index in array ? tuiInspectAny(array[index], depth - 1) : 'empty';
    }
    return `[${result}]`;
}
function inspectObject(object, depth) {
    if (depth === 0) {
        return '{…}';
    }
    let result = '';
    let first = true;
    for (const key in object) {
        if (!object.hasOwnProperty(key)) {
            continue;
        }
        if (first) {
            first = false;
        }
        else {
            result += ', ';
        }
        result += `${key}: ${tuiInspectAny(object[key], depth - 1)}`;
    }
    return `{${result}}`;
}
/**
 * Returns readable JS entity
 * @param data
 * @param depth
 * @return readable JS entity
 */
function tuiInspectAny(data, depth) {
    if (data === null) {
        return 'null';
    }
    switch (typeof data) {
        case 'string':
            return `'${data}'`;
        case 'undefined':
        case 'number':
        case 'boolean':
        case 'function':
            return String(data);
        default:
            break;
    }
    if (data instanceof RegExp) {
        return String(data);
    }
    if (Array.isArray(data)) {
        return inspectArray(data, depth);
    }
    return inspectObject(data, depth);
}

function tuiIsPageGroup(page) {
    return 'subPages' in page;
}

function tuiTryParseMarkdownCodeBlock(text = '') {
    const tokens = new MarkdownIt().parse(text, {});
    const result = tokens
        .filter(({ tag, type }) => tag === 'code' && type === 'fence')
        .map(({ content }) => content.trim());
    return result.length ? result : [text];
}

function tuiRawLoad(content) {
    return __awaiter(this, void 0, void 0, function* () {
        return content instanceof Promise ? (yield content).default : content;
    });
}

function tuiRawLoadRecord(example) {
    return __awaiter(this, void 0, void 0, function* () {
        const processedContent = {};
        for (const [key, content] of Object.entries(example)) {
            if (content) {
                processedContent[key] = yield tuiRawLoad(content);
            }
        }
        return processedContent;
    });
}

function tuiSortPages(pages, excludeSections = new Set()) {
    const sections = Array.from(new Set(pages.map(page => page.section)));
    const sortedPages = pages.slice().sort((a, b) => {
        var _a, _b;
        if (excludeSections.has((_a = a.section) !== null && _a !== void 0 ? _a : '') ||
            excludeSections.has((_b = b.section) !== null && _b !== void 0 ? _b : '')) {
            return 0;
        }
        const aSectionIndex = sections.indexOf(a.section);
        const bSectionIndex = sections.indexOf(b.section);
        if (aSectionIndex !== bSectionIndex) {
            return aSectionIndex - bSectionIndex;
        }
        if (a.title > b.title) {
            return 1;
        }
        return a.title.localeCompare(b.title);
    });
    return sortedPages.map(page => tuiIsPageGroup(page)
        ? Object.assign(Object.assign({}, page), { subPages: tuiSortPages(page.subPages, excludeSections) }) : page);
}

function assertTitle(page, map) {
    var _a;
    if (map.has(page.title) && ((_a = map.get(page.title)) === null || _a === void 0 ? void 0 : _a.route) !== page.route) {
        console.error('Title for page should be unique for prevent inconsistent page names', page, '<== Collisions between ==>', map.get(page.title));
    }
}
function tuiToFlatMapPages(pages) {
    const map = new Map();
    pages.forEach(page => {
        if ('subPages' in page) {
            page.subPages.forEach(subPage => {
                ngDevMode && assertTitle(subPage, map);
                map.set(subPage.title, subPage);
            });
        }
        else {
            ngDevMode && assertTitle(page, map);
            map.set(page.title, page);
        }
    });
    return map;
}

const MAP = {
    а: 'f',
    б: ',',
    в: 'd',
    г: 'u',
    д: 'l',
    е: 't',
    ё: '`',
    ж: ';',
    з: 'p',
    и: 'b',
    й: 'q',
    к: 'r',
    л: 'k',
    м: 'v',
    н: 'y',
    о: 'j',
    п: 'g',
    р: 'h',
    с: 'c',
    т: 'n',
    у: 'e',
    ф: 'a',
    х: '[',
    ц: 'w',
    ч: 'x',
    ш: 'i',
    щ: 'o',
    ъ: ']',
    ы: 's',
    ь: 'm',
    ю: '.',
    я: 'z',
};
/**
 * Translates text mistakenly typed in the Russian layout into English
 * @param string string with Russian layout characters
 * @return string with English layout characters
 */
function tuiTransliterateKeyboardLayout(string) {
    let newStr = '';
    for (let i = 0; i < string.length; i++) {
        newStr += string.charAt(i) in MAP ? MAP[string.charAt(i)] : string.charAt(i);
    }
    return newStr;
}

function tuiTypeReferenceParser(types) {
    const generics = types.match(/<([^>]+)>/g);
    const escaped = generics
        ? generics
            .reduce((result, current) => result.replace(current, current.replace(/\|/g, '&')), types)
            .split('|')
            .map(item => item.trim())
        : types.split('|').map(item => item.trim());
    return escaped.reduce((result, type) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        let extracted = type
            .trim()
            .replace(/readonly /g, '')
            .replace(/\[\]/g, '');
        extracted =
            (_d = (_c = (_b = (_a = extracted.match(/ReadonlyArray<([^>]+)>/)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.split('&')) === null || _c === void 0 ? void 0 : _c[0]) !== null && _d !== void 0 ? _d : extracted;
        extracted = (_h = (_g = (_f = (_e = extracted.match(/\[([^\]]+)\]/)) === null || _e === void 0 ? void 0 : _e[1]) === null || _f === void 0 ? void 0 : _f.split(',')) === null || _g === void 0 ? void 0 : _g[0]) !== null && _h !== void 0 ? _h : extracted;
        extracted = (_m = (_l = ((_k = (_j = extracted.split('<')) === null || _j === void 0 ? void 0 : _j[0]) !== null && _k !== void 0 ? _k : extracted)) === null || _l === void 0 ? void 0 : _l.trim()) !== null && _m !== void 0 ? _m : '';
        extracted = Number.isNaN(parseFloat(extracted)) ? extracted : 'number';
        extracted = /^'(.+)'$|^"(.+)"$|^`(.+)`$/.test(extracted) ? 'string' : extracted;
        extracted = extracted.length === 1 ? 'unknown' : extracted;
        return result.concat({ type: type.replace(/&/g, '|'), extracted });
    }, []);
}

/**
 * Generated bundle index. Do not edit.
 */

export { tuiCoerceValue, tuiCoerceValueIsTrue, tuiGenerateRoutes, tuiInspectAny, tuiIsPageGroup, tuiRawLoad, tuiRawLoadRecord, tuiSortPages, tuiToFlatMapPages, tuiTransliterateKeyboardLayout, tuiTryParseMarkdownCodeBlock, tuiTypeReferenceParser };
//# sourceMappingURL=taiga-ui-addon-doc-utils.js.map
