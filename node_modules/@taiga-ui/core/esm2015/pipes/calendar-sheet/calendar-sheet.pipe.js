import { Inject, Pipe } from '@angular/core';
import { DAYS_IN_WEEK } from '@taiga-ui/cdk';
import { TUI_FIRST_DAY_OF_WEEK } from '@taiga-ui/core/tokens';
import { getDayFromMonthRowCol } from './utils';
import * as i0 from "@angular/core";
import * as i1 from "@taiga-ui/cdk";
const CALENDAR_ROWS_COUNT = 6;
export class TuiCalendarSheetPipe {
    constructor(firstDayOfWeek) {
        this.firstDayOfWeek = firstDayOfWeek;
        this.currentMonth = null;
        this.currentSheet = [];
    }
    transform(month, showAdjacentDays = false) {
        var _a;
        if ((_a = this.currentMonth) === null || _a === void 0 ? void 0 : _a.monthSame(month)) {
            return this.currentSheet;
        }
        const sheet = [];
        for (let rowIndex = 0; rowIndex < CALENDAR_ROWS_COUNT; rowIndex++) {
            const row = [];
            for (let colIndex = 0; colIndex < DAYS_IN_WEEK; colIndex++) {
                const day = getDayFromMonthRowCol({
                    month,
                    rowIndex,
                    colIndex,
                    firstDayOfWeek: this.firstDayOfWeek,
                });
                const isPrevMonthDay = (day, relativeToMonth = month) => day.year < relativeToMonth.year || day.month < relativeToMonth.month;
                const isNextMonthDay = (day, relativeToMonth = month) => day.year > relativeToMonth.year || day.month > relativeToMonth.month;
                if (isPrevMonthDay(day) && !showAdjacentDays) {
                    continue;
                }
                if (isNextMonthDay(day) && !showAdjacentDays) {
                    break;
                }
                row.push(day);
            }
            sheet.push(row);
        }
        this.currentSheet = sheet.filter(row => row.length);
        this.currentMonth = month;
        return this.currentSheet;
    }
}
TuiCalendarSheetPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiCalendarSheetPipe, deps: [{ token: TUI_FIRST_DAY_OF_WEEK }], target: i0.ɵɵFactoryTarget.Pipe });
TuiCalendarSheetPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiCalendarSheetPipe, name: "tuiCalendarSheet" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TuiCalendarSheetPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'tuiCalendarSheet',
                }]
        }], ctorParameters: function () { return [{ type: i1.TuiDayOfWeek, decorators: [{
                    type: Inject,
                    args: [TUI_FIRST_DAY_OF_WEEK]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItc2hlZXQucGlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUvcGlwZXMvY2FsZW5kYXItc2hlZXQvY2FsZW5kYXItc2hlZXQucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBZ0IsTUFBTSxlQUFlLENBQUM7QUFDMUQsT0FBTyxFQUFDLFlBQVksRUFBaUMsTUFBTSxlQUFlLENBQUM7QUFDM0UsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFNUQsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sU0FBUyxDQUFDOzs7QUFFOUMsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLENBQUM7QUFLOUIsTUFBTSxPQUFPLG9CQUFvQjtJQUk3QixZQUVxQixjQUE0QjtRQUE1QixtQkFBYyxHQUFkLGNBQWMsQ0FBYztRQUx6QyxpQkFBWSxHQUFvQixJQUFJLENBQUM7UUFDckMsaUJBQVksR0FBcUMsRUFBRSxDQUFDO0lBS3pELENBQUM7SUFFSixTQUFTLENBQ0wsS0FBZSxFQUNmLG1CQUE0QixLQUFLOztRQUVqQyxJQUFJLE1BQUEsSUFBSSxDQUFDLFlBQVksMENBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3JDLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztTQUM1QjtRQUVELE1BQU0sS0FBSyxHQUE2QixFQUFFLENBQUM7UUFFM0MsS0FBSyxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUUsUUFBUSxHQUFHLG1CQUFtQixFQUFFLFFBQVEsRUFBRSxFQUFFO1lBQy9ELE1BQU0sR0FBRyxHQUFhLEVBQUUsQ0FBQztZQUV6QixLQUFLLElBQUksUUFBUSxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsWUFBWSxFQUFFLFFBQVEsRUFBRSxFQUFFO2dCQUN4RCxNQUFNLEdBQUcsR0FBRyxxQkFBcUIsQ0FBQztvQkFDOUIsS0FBSztvQkFDTCxRQUFRO29CQUNSLFFBQVE7b0JBQ1IsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjO2lCQUN0QyxDQUFDLENBQUM7Z0JBRUgsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFXLEVBQUUsZUFBZSxHQUFHLEtBQUssRUFBVyxFQUFFLENBQ3JFLEdBQUcsQ0FBQyxJQUFJLEdBQUcsZUFBZSxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsS0FBSyxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUM7Z0JBRXpFLE1BQU0sY0FBYyxHQUFHLENBQUMsR0FBVyxFQUFFLGVBQWUsR0FBRyxLQUFLLEVBQVcsRUFBRSxDQUNyRSxHQUFHLENBQUMsSUFBSSxHQUFHLGVBQWUsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDO2dCQUV6RSxJQUFJLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFO29CQUMxQyxTQUFTO2lCQUNaO2dCQUVELElBQUksY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7b0JBQzFDLE1BQU07aUJBQ1Q7Z0JBRUQsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNqQjtZQUVELEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbkI7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7UUFFMUIsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzdCLENBQUM7O2tIQXREUSxvQkFBb0Isa0JBS2pCLHFCQUFxQjtnSEFMeEIsb0JBQW9COzRGQUFwQixvQkFBb0I7a0JBSGhDLElBQUk7bUJBQUM7b0JBQ0YsSUFBSSxFQUFFLGtCQUFrQjtpQkFDM0I7OzBCQU1RLE1BQU07MkJBQUMscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3QsIFBpcGUsIFBpcGVUcmFuc2Zvcm19IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEQVlTX0lOX1dFRUssIFR1aURheSwgVHVpRGF5T2ZXZWVrLCBUdWlNb250aH0gZnJvbSAnQHRhaWdhLXVpL2Nkayc7XG5pbXBvcnQge1RVSV9GSVJTVF9EQVlfT0ZfV0VFS30gZnJvbSAnQHRhaWdhLXVpL2NvcmUvdG9rZW5zJztcblxuaW1wb3J0IHtnZXREYXlGcm9tTW9udGhSb3dDb2x9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBDQUxFTkRBUl9ST1dTX0NPVU5UID0gNjtcblxuQFBpcGUoe1xuICAgIG5hbWU6ICd0dWlDYWxlbmRhclNoZWV0Jyxcbn0pXG5leHBvcnQgY2xhc3MgVHVpQ2FsZW5kYXJTaGVldFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwcml2YXRlIGN1cnJlbnRNb250aDogVHVpTW9udGggfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIGN1cnJlbnRTaGVldDogUmVhZG9ubHlBcnJheTxyZWFkb25seSBUdWlEYXlbXT4gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KFRVSV9GSVJTVF9EQVlfT0ZfV0VFSylcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBmaXJzdERheU9mV2VlazogVHVpRGF5T2ZXZWVrLFxuICAgICkge31cblxuICAgIHRyYW5zZm9ybShcbiAgICAgICAgbW9udGg6IFR1aU1vbnRoLFxuICAgICAgICBzaG93QWRqYWNlbnREYXlzOiBib29sZWFuID0gZmFsc2UsXG4gICAgKTogUmVhZG9ubHlBcnJheTxyZWFkb25seSBUdWlEYXlbXT4ge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TW9udGg/Lm1vbnRoU2FtZShtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGVldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNoZWV0OiBBcnJheTxyZWFkb25seSBUdWlEYXlbXT4gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgQ0FMRU5EQVJfUk9XU19DT1VOVDsgcm93SW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBUdWlEYXlbXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBjb2xJbmRleCA9IDA7IGNvbEluZGV4IDwgREFZU19JTl9XRUVLOyBjb2xJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF5ID0gZ2V0RGF5RnJvbU1vbnRoUm93Q29sKHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGgsXG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXlPZldlZWs6IHRoaXMuZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1ByZXZNb250aERheSA9IChkYXk6IFR1aURheSwgcmVsYXRpdmVUb01vbnRoID0gbW9udGgpOiBib29sZWFuID0+XG4gICAgICAgICAgICAgICAgICAgIGRheS55ZWFyIDwgcmVsYXRpdmVUb01vbnRoLnllYXIgfHwgZGF5Lm1vbnRoIDwgcmVsYXRpdmVUb01vbnRoLm1vbnRoO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNOZXh0TW9udGhEYXkgPSAoZGF5OiBUdWlEYXksIHJlbGF0aXZlVG9Nb250aCA9IG1vbnRoKTogYm9vbGVhbiA9PlxuICAgICAgICAgICAgICAgICAgICBkYXkueWVhciA+IHJlbGF0aXZlVG9Nb250aC55ZWFyIHx8IGRheS5tb250aCA+IHJlbGF0aXZlVG9Nb250aC5tb250aDtcblxuICAgICAgICAgICAgICAgIGlmIChpc1ByZXZNb250aERheShkYXkpICYmICFzaG93QWRqYWNlbnREYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc05leHRNb250aERheShkYXkpICYmICFzaG93QWRqYWNlbnREYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKGRheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoZWV0LnB1c2gocm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFNoZWV0ID0gc2hlZXQuZmlsdGVyKHJvdyA9PiByb3cubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TW9udGggPSBtb250aDtcblxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2hlZXQ7XG4gICAgfVxufVxuIl19