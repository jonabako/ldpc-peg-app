import { tuiAssert } from '@taiga-ui/cdk/classes';
function errorSet(key, component) {
    return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;
}
/**
 * @deprecated:
 * not compatible with TypeScript 5
 *
 * Decorator for checking input setter values against a custom assertion which
 * takes value passed to input setter and component instance as arguments.
 * It specifically checks for undefined values and prevents calls to the
 * original setter in this case.
 */
export function tuiRequiredSetter(assertion, ...args) {
    return (target, key, { configurable, enumerable, get, set }) => {
        const { name } = target.constructor;
        return {
            configurable,
            enumerable,
            get,
            set(value) {
                if (ngDevMode && value !== undefined && assertion && tuiAssert) {
                    tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);
                }
                if (!set || value === undefined) {
                    ngDevMode &&
                        tuiAssert.assert(value !== undefined, errorSet(key, name));
                    return;
                }
                set.call(this, value);
            },
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWlyZWQtc2V0dGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY2RrL2RlY29yYXRvcnMvcmVxdWlyZWQtc2V0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUdoRCxTQUFTLFFBQVEsQ0FBQyxHQUFvQixFQUFFLFNBQWlCO0lBQ3JELE9BQU8sMkJBQTJCLE1BQU0sQ0FDcEMsR0FBRyxDQUNOLE9BQU8sU0FBUyw2QkFBNkIsQ0FBQztBQUNuRCxDQUFDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQzdCLFNBQW1DLEVBQ25DLEdBQUcsSUFBVztJQUVkLE9BQU8sQ0FDSCxNQUEyQixFQUMzQixHQUFHLEVBQ0gsRUFBQyxZQUFZLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQXFCLEVBQ3RDLEVBQUU7UUFDcEIsTUFBTSxFQUFDLElBQUksRUFBQyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFFbEMsT0FBTztZQUNILFlBQVk7WUFDWixVQUFVO1lBQ1YsR0FBRztZQUNILEdBQUcsQ0FBVSxLQUFXO2dCQUNwQixJQUFJLFNBQVMsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLFNBQVMsSUFBSSxTQUFTLEVBQUU7b0JBQzVELFNBQVMsQ0FBQyxNQUFNLENBQ1osU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQzNCLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksWUFBWSxFQUNyQyxLQUFLLEVBQ0wsR0FBRyxJQUFJLENBQ1YsQ0FBQztpQkFDTDtnQkFFRCxJQUFJLENBQUMsR0FBRyxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7b0JBQzdCLFNBQVM7d0JBQ0wsU0FBUyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFLFFBQVEsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztvQkFFL0QsT0FBTztpQkFDVjtnQkFFRCxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMxQixDQUFDO1NBQ0osQ0FBQztJQUNOLENBQUMsQ0FBQztBQUNOLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3R1aUFzc2VydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9jbGFzc2VzJztcbmltcG9ydCB7VHVpQm9vbGVhbkhhbmRsZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvdHlwZXMnO1xuXG5mdW5jdGlvbiBlcnJvclNldChrZXk6IHN0cmluZyB8IHN5bWJvbCwgY29tcG9uZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVW5kZWZpbmVkIHdhcyBwYXNzZWQgYXMgJHtTdHJpbmcoXG4gICAgICAgIGtleSxcbiAgICApfSB0byAke2NvbXBvbmVudH0sIHNldHRlciB3aWxsIG5vdCBiZSBjYWxsZWRgO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkOlxuICogbm90IGNvbXBhdGlibGUgd2l0aCBUeXBlU2NyaXB0IDVcbiAqXG4gKiBEZWNvcmF0b3IgZm9yIGNoZWNraW5nIGlucHV0IHNldHRlciB2YWx1ZXMgYWdhaW5zdCBhIGN1c3RvbSBhc3NlcnRpb24gd2hpY2hcbiAqIHRha2VzIHZhbHVlIHBhc3NlZCB0byBpbnB1dCBzZXR0ZXIgYW5kIGNvbXBvbmVudCBpbnN0YW5jZSBhcyBhcmd1bWVudHMuXG4gKiBJdCBzcGVjaWZpY2FsbHkgY2hlY2tzIGZvciB1bmRlZmluZWQgdmFsdWVzIGFuZCBwcmV2ZW50cyBjYWxscyB0byB0aGVcbiAqIG9yaWdpbmFsIHNldHRlciBpbiB0aGlzIGNhc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0dWlSZXF1aXJlZFNldHRlcjxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiwgSyBleHRlbmRzIGtleW9mIFQ+KFxuICAgIGFzc2VydGlvbj86IFR1aUJvb2xlYW5IYW5kbGVyPFRbS10+LFxuICAgIC4uLmFyZ3M6IGFueVtdXG4pOiBNZXRob2REZWNvcmF0b3Ige1xuICAgIHJldHVybiAoXG4gICAgICAgIHRhcmdldDogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICAga2V5LFxuICAgICAgICB7Y29uZmlndXJhYmxlLCBlbnVtZXJhYmxlLCBnZXQsIHNldH06IFByb3BlcnR5RGVzY3JpcHRvcixcbiAgICApOiBQcm9wZXJ0eURlc2NyaXB0b3IgPT4ge1xuICAgICAgICBjb25zdCB7bmFtZX0gPSB0YXJnZXQuY29uc3RydWN0b3I7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICBzZXQodGhpczogVCwgdmFsdWU6IFRbS10pIHtcbiAgICAgICAgICAgICAgICBpZiAobmdEZXZNb2RlICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgYXNzZXJ0aW9uICYmIHR1aUFzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0aW9uLmNhbGwodGhpcywgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7U3RyaW5nKGtleSl9IGluICR7bmFtZX0gcmVjZWl2ZWQ6YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHVpQXNzZXJ0LmFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCBlcnJvclNldChrZXksIG5hbWUpKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xufVxuIl19