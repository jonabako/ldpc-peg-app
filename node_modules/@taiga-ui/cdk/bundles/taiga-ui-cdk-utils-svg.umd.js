(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/utils/miscellaneous')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/utils/svg', ['exports', '@taiga-ui/cdk/utils/miscellaneous'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global["taiga-ui"] = global["taiga-ui"] || {}, global["taiga-ui"].cdk = global["taiga-ui"].cdk || {}, global["taiga-ui"].cdk.utils = global["taiga-ui"].cdk.utils || {}, global["taiga-ui"].cdk.utils.svg = {}), global["taiga-ui"].cdk.utils.miscellaneous));
})(this, (function (exports, miscellaneous) { 'use strict';

    function makeRandomSalt() {
        return Math.floor(Math.random() * Date.now());
    }
    function escapeRegExp(search) {
        return search.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }
    function extractLinearGradientIdsFromSvg(svg) {
        var _a;
        var ids = ((_a = svg.match(/url\(("?)('*)#(.*?)('*)\)/g)) !== null && _a !== void 0 ? _a : []).map(function (url) { return url.slice(4, url.length - 1).replace(/['"#]+/g, ''); });
        return Array.from(new Set(ids));
    }
    /**
     * TODO: remove in v4.0
     * @deprecated
     */
    function setFallbackForGradientFill(svg, fallback) {
        try {
            var tree = new DOMParser().parseFromString(svg, 'text/html');
            tree.body
                .querySelectorAll('[fill^=url]') // only gradient
                .forEach(function (element) { return element.setAttribute('fill', (element.getAttribute('fill') + " " + fallback).trim()); });
            return tree.body.innerHTML.trim();
        }
        catch (_a) {
            return svg;
        }
    }
    /**
     * @description:
     * Any ‘linearGradient’ attributes which are defined on the referenced
     * element which are not defined on this element are inherited by this element.
     * If this element has no defined gradient stops, and the referenced element does
     * (possibly due to its own ‘xlink:href’ attribute), then this element inherits
     * the gradient stop from the referenced element. Inheritance can be indirect
     * to an arbitrary level; thus, if the referenced element inherits attribute
     * or gradient stops due to its own ‘xlink:href’ attribute, then the current
     * element can inherit those attributes or gradient stops.
     *
     * Documentation: https://www.w3.org/TR/SVG11/pservers.html
     *
     */
    function tuiSvgLinearGradientProcessor(svg, salt, 
    /**
     * TODO: remove in v4.0
     * @deprecated
     */
    fallback) {
        if (salt === void 0) { salt = makeRandomSalt(); }
        if (fallback === void 0) { fallback = 'rgba(0, 0, 0, 0.7)'; }
        if (miscellaneous.tuiIsString(svg)) {
            var uniqueIds = extractLinearGradientIdsFromSvg(svg);
            var rawSvg = uniqueIds.reduce(function (newSvg, previousId) {
                var escapedId = escapeRegExp(previousId);
                var newId = "id_" + salt + "_" + previousId;
                return newSvg
                    .replace(new RegExp("\"" + escapedId + "\"", 'g'), "\"" + newId + "\"")
                    .replace(new RegExp("'" + escapedId + "'", 'g'), "'" + newId + "'")
                    .replace(new RegExp("url\\('#" + escapedId + "'\\)", 'g'), "url('#" + newId + "')")
                    .replace(new RegExp("url\\(\"#" + escapedId + "\"\\)", 'g'), "url(\"#" + newId + "\")")
                    .replace(new RegExp("url\\(#" + escapedId + "\\)", 'g'), "url(#" + newId + ")");
            }, svg);
            return setFallbackForGradientFill(rawSvg, fallback);
        }
        return svg;
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.tuiSvgLinearGradientProcessor = tuiSvgLinearGradientProcessor;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=taiga-ui-cdk-utils-svg.umd.js.map
