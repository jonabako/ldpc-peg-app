function tuiHexToRgb(hex) {
    const matches = hex
        .replace('#', '')
        .split('')
        .map((char, _, array) => (array.length === 3 ? char + char : char))
        .join('')
        .match(/.{2}/g);
    return matches
        ? matches.map(x => Number.parseInt(x, 16))
        : [0, 0, 0];
}

const getChunksFromString = (hex, chunkSize) => hex.match(new RegExp(`.{${chunkSize}}`, 'g'));
const convertHexUnitTo256 = (hexStr) => parseInt(hexStr.repeat(2 / hexStr.length), 16);
const getAlphaFloat = (a, alpha) => {
    if (typeof a !== 'undefined') {
        return Number((a / 255).toFixed(2));
    }
    if (typeof alpha !== 'number' || alpha < 0 || alpha > 1) {
        return 1;
    }
    return alpha;
};
function tuiHexToRGBA(hex, alpha) {
    const [r, g, b, a] = tuiParseHex(hex, alpha);
    return a < 1 ? `rgba(${r}, ${g}, ${b}, ${a})` : `rgb(${r}, ${g}, ${b})`;
}
function tuiIsValidHex(hex) {
    // eslint-disable-next-line unicorn/no-unsafe-regex
    return /^#([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);
}
function tuiParseHex(hex, alpha) {
    var _a;
    if (!tuiIsValidHex(hex)) {
        throw new Error('Invalid HEX');
    }
    const chunkSize = Math.floor((hex.length - 1) / 3);
    const hexArr = getChunksFromString(hex.slice(1), chunkSize);
    const [r, g, b, a] = (_a = hexArr === null || hexArr === void 0 ? void 0 : hexArr.map(convertHexUnitTo256)) !== null && _a !== void 0 ? _a : [];
    const floatAlpha = getAlphaFloat(a, alpha);
    return [r, g, b, floatAlpha];
}

function hsvToColor(h, s, v, n) {
    const k = (n + h / 60) % 6;
    return Math.round(v - v * s * Math.max(Math.min(k, 4 - k, 1), 0));
}
/**
 * https://stackoverflow.com/a/54024653/2706426
 */
function tuiHsvToRgb(h, s, v) {
    return [hsvToColor(h, s, v, 5), hsvToColor(h, s, v, 3), hsvToColor(h, s, v, 1)];
}

const DEFAULT = [0, 0, 0, 1];
function tuiParseColor(color) {
    const stripped = color
        .replace('#', '')
        .replace('rgba(', '')
        .replace('rgb(', '')
        .replace(')', '');
    const array = stripped.split(',').map(item => parseFloat(item));
    if (array.length === 4) {
        return array;
    }
    if (array.length === 3) {
        return array.concat(1);
    }
    const matches = stripped.match(new RegExp(`(.{${stripped.length / 3}})`, 'g'));
    if (!matches) {
        return DEFAULT;
    }
    const parsed = matches.map(char => parseInt(stripped.length % 2 ? char + char : char, 16));
    return [
        parsed[0] || DEFAULT[0],
        parsed[1] || DEFAULT[1],
        parsed[2] || DEFAULT[2],
        parsed[3] === undefined ? DEFAULT[3] : parsed[3],
    ];
}

function tuiRgbToHex(r, g, b) {
    return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;
}

function tuiRgbToHsv(r, g, b) {
    const v = Math.max(r, g, b);
    const n = v - Math.min(r, g, b);
    // eslint-disable-next-line no-nested-ternary
    const h = n && (v === r ? (g - b) / n : v === g ? 2 + (b - r) / n : 4 + (r - g) / n);
    return [60 * (h < 0 ? h + 6 : h), v && n / v, v];
}

function tuiRgbaToHex(color) {
    var _a, _b;
    if (!tuiIsValidRgba(color)) {
        throw new Error('Invalid RGBa');
    }
    const rgb = (_a = color
        .replace(/\s/g, '')
        // eslint-disable-next-line unicorn/no-unsafe-regex
        .match(/^rgba?\((\d+),(\d+),(\d+),?([^,\s)]+)?/i)) !== null && _a !== void 0 ? _a : [];
    let alpha = ((_b = rgb === null || rgb === void 0 ? void 0 : rgb[4]) !== null && _b !== void 0 ? _b : '').toString().trim();
    let hex = rgb
        ? (rgb[1] | (1 << 8)).toString(16).slice(1) +
            (rgb[2] | (1 << 8)).toString(16).slice(1) +
            (rgb[3] | (1 << 8)).toString(16).slice(1)
        : color;
    alpha = alpha !== '' ? alpha : 0o1;
    alpha = ((Number(alpha) * 255) | (1 << 8)).toString(16).slice(1);
    hex += alpha;
    return `#${hex.toUpperCase()}`;
}
function tuiIsValidRgba(rgba) {
    const range = '(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|2[0-5]{2})';
    const alpha = '([01]|0?\\.\\d+)';
    return new RegExp(`^(?:rgb\\(\\s*${range}\\s*,\\s*${range}\\s*,\\s*${range}\\s*\\)|rgba\\(\\s*${range}\\s*,\\s*${range}\\s*,\\s*${range}\\s*,\\s*${alpha}\\s*\\))$`).test(rgba);
}

/**
 * Generated bundle index. Do not edit.
 */

export { tuiHexToRGBA, tuiHexToRgb, tuiHsvToRgb, tuiIsValidHex, tuiIsValidRgba, tuiParseColor, tuiParseHex, tuiRgbToHex, tuiRgbToHsv, tuiRgbaToHex };
//# sourceMappingURL=taiga-ui-cdk-utils-color.js.map
